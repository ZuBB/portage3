#!/usr/bin/env ruby
# encoding: UTF-8
#
# Here should go some comment
#
# Initial Author: Vasyl Zuzyak, 01/04/12
# Latest Modification: Vasyl Zuzyak, 01/06/12
#
$:.push File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'optparse'
require 'rubygems'
require 'nokogiri'
require 'sqlite3'
require 'tools'

def is_category_invalid(portage_home, category)
    # skip system dirs
    return true if ['.', '..'].index(category) != nil
    # skip files
    return true if File.file?(File.join(portage_home, category))
    #TODO what to do with this?
    return true if category.index('-') == nil
    # valid one! :)
    return false
end

def fill_categories_table(database, portage_home)
    queries_array = []
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # process all another items
        metadata_path = File.join(portage_home, category, "metadata.xml")
        if File.exists?(metadata_path) && File.readable?(metadata_path)
            xml_doc = Nokogiri::XML(IO.read(metadata_path))
            # TODO hardcoded 'en'
            description_node = xml_doc.xpath('//longdescription[@lang="en"]')
            description = description_node.children.to_s.strip.gsub(/\s{1,}/, ' ')
        end

        sql_query = <<SQL
    INSERT INTO categories
    (category_name, description)
    VALUES ('#{category}', "#{description || ''}");
SQL
        queries_array << sql_query
    end

    # TODO try/catch
    database.execute_batch(queries_array.join("\n"))
end

def is_package_invalid(item_path, package)
    # skip system dirs
    return true if ['.', '..'].index(package) != nil
    # skip if it is a file
    return true if  File.file?(item_path)
    # valid one! :)
    return false
end

def fill_packages_table(database, portage_home)
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # get id of the current category from our db
        sql_query = "SELECT id FROM categories WHERE category_name=?;"
        category_id = database.execute(sql_query, category)[0]

        # lets walk through all items in category dir
        Dir.new(File.join(portage_home, category)).sort.each do |package|
            # lets get full path for this item
            item_path = File.join(portage_home, category, package)
            # skip if it is a ..
            next if is_package_invalid(item_path, package)

            # get content of the last ebuild for this package
            ebuild_text = IO.read(Dir.glob(item_path + '/*.ebuild').sort.last).to_a
            description = get_ebuild_description(ebuild_text)
            homepage = get_ebuild_homepage(ebuild_text)

            sql_query = <<SQL
    INSERT INTO packages
    (category_id, package_name, description, homepage)
    VALUES (?, ?, ?, ?);
SQL
            database.execute(sql_query, category_id, package, description, homepage)
        end
    end
end

def get_package_maintainers(database, item_path)
    persons = []
    metadata_path = File.join(item_path, "metadata.xml")
    return persons unless (File.readable?(metadata_path) rescue false)

    Nokogiri::XML(IO.read(metadata_path)).xpath("//maintainer").each do |node|
        # lets get email and name
        email = node.xpath('email').inner_text rescue ''
        name = node.xpath('name').inner_text rescue ''
        # TODO <description>Proxying maintainer.</description> and possible other tags

        # skip if email is empty or email is a stub
        next nil if email.empty? || 'maintainer-needed@gentoo.org' == email

        person = {}
        person["name"] = name
        person["email"] = email
        person["responsibility"] = node.parent().name() == 'upstream' ?
            "upstream maintainer" : "gentoo maintainer"
        persons << person
    end

    return persons
end

def store_persons(database, persons)
    persons.each do |person|
        sql_query = "SELECT * FROM persons WHERE email=?;"
        result = database.execute(sql_query, person["email"])

        if (result.empty?)
            sql_query = "INSERT INTO persons (email, name) VALUES (?, ?);"
            database.execute(sql_query, person["email"], person["name"])
            person["person_id"] = get_last_inserted_id(database)
        else
            if !person["name"].empty? && result[0][1].empty?
                sql_query = "UPDATE persons SET name=? where id=?;"
                database.execute(sql_query, person["name"], result[0][0])
            end
            person["person_id"] = result[0][0]
        end
    end
end

def store_persons_responsibilities(database, persons)
    sql_query = <<SQL
INSERT OR IGNORE INTO persons2responsibilities
(person_id, responsibility_id)
VALUES (?, (
    SELECT id
    FROM responsibilities
    WHERE responsibility=?
));
SQL

    persons.each do |person|
        database.execute(sql_query, person["person_id"], person["responsibility"])
        person["responsibility_id"] = get_last_inserted_id(database)
    end
end

def store_package_maintainers(database, persons, category, package)
    sql_query = <<SQL
INSERT INTO maintainers2packages
(maintainer_id, package_id)
VALUES (?, (
    SELECT packages.id
    FROM packages, categories
    WHERE
        categories.category_name=? and
        packages.category_id = categories.id and
        packages.package_name=?
));
SQL

    persons.each do |person|
        database.execute(sql_query, person["responsibility_id"], category, package)
    end
end

def fill_maintainers_table(database, portage_home)
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # lets walk through all items in category dir
        Dir.new(File.join(portage_home, category)).sort.each do |package|
            # lets get full path for this item
            item_path = File.join(portage_home, category, package)
            # skip if it is a ..
            next if is_package_invalid(item_path, package)

            persons = get_package_maintainers(database, item_path)
            persons = store_persons(database, persons)
            persons = store_persons_responsibilities(database, persons)
            store_package_maintainers(database, persons, category, package)
        end
    end
end

def get_ebuild_description(ebuild_text)
    ebuild_text.each { |line|
        return get_clean_value(line) if line.index('DESCRIPTION=') != nil
    }

    return ''
end

def get_ebuild_homepage(ebuild_text)
    ebuild_text.each { |line|
        return get_clean_value(line) if line.index('HOMEPAGE=') != nil
    }

    return ''
end

def get_ebuild_mtime(ebuild_text)
    ebuild_text.each { |line|
        if line.index('# $Header:') != nil
            # https://bugs.gentoo.org/show_bug.cgi?id=398567
            return line.match(/\d{4}\/\d\d\/\d\d \d\d:\d\d:\d\d/).to_s rescue '1970'
        end
    }

    return ''
end

def get_ebuild_author(ebuild_text)
    ebuild_text.each { |line|
        if line.index('# $Header:') != nil
            # https://bugs.gentoo.org/show_bug.cgi?id=398567
            return line.match(/:\d\d ([\w_\-\.]+) Exp \$$/)[1].to_s rescue 'anonymous'
        end
    }

    return ''
end

def get_eapi(ebuild_text)
    ebuild_text.each { |line|
        return get_clean_value(line) if line.index('EAPI') != nil
    }

    return 'unknown'
end

def get_slot(ebuild_text)
    ebuild_text.each { |line|
        # app-editors/nvi/nvi-1.81.6-r3.ebuild
        return get_clean_value(line) if line.index('SLOT') == 0
    }

    return ''
end

def get_license(ebuild_text)
    ebuild_text.each { |line|
        return get_clean_value(line) if line.index('LICENSE') != nil
    }

    return ''
end

def get_ebuild_version(ebuild_filename)
    result = 'undefined'
    filename = File.basename(ebuild_filename, ".ebuild")
    match = filename.match('-\d').to_s

    if match.nil? || match.empty?
        puts 'Failed to get version for ' + ebuild_filename
    else
        position = filename.index(match)
        result = filename[(position + 1)..-1]
    end

    return result
end

def parse_ebuild(database, category, package, ebuild_filename)
    ebuild_obj = { "version" => get_ebuild_version(ebuild_filename) }
    ebuild_text = nil
    #p ebuild_filename

    begin
        ebuild_text = IO.read(ebuild_filename).to_a
    rescue => err
        puts "Exception: #{err}"
    end
        ebuild_obj["mtime"] = get_ebuild_mtime(ebuild_text)
        ebuild_obj["author"] = get_ebuild_author(ebuild_text)
        ebuild_obj["eapi"] = get_eapi(ebuild_text)
        ebuild_obj["slot"] = get_slot(ebuild_text)
        ebuild_obj["license"] = get_license(ebuild_text)

    sql_query = <<SQL
INSERT INTO ebuilds
(package_id, version, mtime, mauthor, eapi, slot, license)
VALUES ((
    SELECT packages.id
    FROM packages, categories
    WHERE
        categories.category_name=? and
        packages.package_name=? and
        packages.category_id = categories.id
), ?, ?, ?, ?, ?, ?);
SQL

    database.execute(
        sql_query, 
        category,
        package,
        ebuild_obj["version"],
        ebuild_obj["mtime"],
        ebuild_obj["author"],
        ebuild_obj["eapi"],
        ebuild_obj["slot"],
        ebuild_obj["license"]
    )
end

def fill_ebuilds_table(database, portage_home)
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # lets walk through all items in category dir
        Dir.new(File.join(portage_home, category)).sort.each do |package|
            # lets get full path for this item
            item_path = File.join(portage_home, category, package)
            # skip if it is a ..
            next if is_package_invalid(item_path, package)

            Dir.glob(File.join(item_path, '*.ebuild')).sort.each do |ebuild|
                parse_ebuild(database, category, package, ebuild)
            end
        end
    end
end

# hash with options
options = {
    :db_filename => nil,
    :storage => {},
    :quiet => true
}

# lets merge stuff from tools lib
options[:storage].merge!(STORAGE)
# get last created database
options[:db_filename] = get_last_created_database(
    options[:storage][:root],
    options[:storage][:home_folder]
)

OptionParser.new do |opts|
    # help header
    opts.banner = " Usage: purge_s3_data [options]\n"
    opts.separator " A script that purges outdated data from s3 bucket\n"

    opts.on("-f", "--database-file STRING", "Path where new database file will be created") do |value|
        # TODO check if path id valid
        options[:db_filename] = value
    end

    # parsing 'quite' option if present
    opts.on("-q", "--quiet", "Quiet mode") do |value|
        options[:quiet] = true
    end

    # parsing 'help' option if present
    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end
end.parse!

portage_home = File.join(
    options[:storage][:root],
    options[:storage][:home_folder],
    options[:storage][:portage_home]
)

#begin
    db = SQLite3::Database.new(options[:db_filename])

    start = Time.now

    # fill ebuilds data
    fill_categories_table(db, portage_home)
    fill_packages_table(db, portage_home)
    fill_maintainers_table(db, portage_home)
    fill_ebuilds_table(db, portage_home)

    finish = Time.now

    puts 'Everything is OK!'
    puts start
    puts finish
#rescue Exception => msg
    #File.delete(options[:db_filename])
    #puts msg
#ensure
    db.close() if db.closed? == false
#end
