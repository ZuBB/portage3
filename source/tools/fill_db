#!/usr/bin/env ruby
#
# Here should go some comment
#
# Initial Author: Vasyl Zuzyak, 01/04/12
# Latest Modification: Vasyl Zuzyak, 01/06/12
#
$:.push File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'optparse'
require 'rubygems'
require 'nokogiri'
require 'sqlite3'
require 'tools'

def get_last_created_database(root_path, home_folder)
    # get last test database
    return Dir.glob(File.join(root_path, home_folder) + '/*.sqlite').sort.last
end

def fill_architecture_table(database, portage_home)
    # array of all inserts
    queries_array = []
    # walk through all items in architectures dir
    Dir.new(File.join(portage_home, "profiles/arch")).sort.each do |arch|
        # skip system dirs
        next if ['.', '..'].index(arch) != nil
        # create query for current arch
        query = "INSERT INTO architectures (architecture) VALUES ('#{arch}');"
        # add query into array
        queries_array << query
    end

    # TODO try/catch
    database.execute_batch(queries_array.join("\n"))
end

def fill_keywords_table(database)
    # array of all inserts
    queries_array = []
    # array of all keywords
    ['stable', 'unstable', 'hardmasked'].each { |keyword|
        # create query for keyword and add it into array
        queries_array << "INSERT INTO keywords (keyword) VALUES ('#{keyword}');"
    }

    # TODO try/catch
    database.execute_batch(queries_array.join("\n"))
end

def is_category_invalid(portage_home, category)
    # skip system dirs
    return true if ['.', '..'].index(category) != nil
    # skip files
    return true if File.file?(File.join(portage_home, category))
    #TODO what to do with this?
    return true if category.index('-') == nil
    # valid one! :)
    return false
end

def fill_categories_table(database, portage_home)
    queries_array = []
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # process all another items
        metadata_path = File.join(portage_home, category, "metadata.xml")
        if File.exists?(metadata_path) && File.readable?(metadata_path)
            xml_doc = Nokogiri::XML(IO.read(metadata_path))
            # TODO hardcoded 'en'
            description_node = xml_doc.xpath('//longdescription[@lang="en"]')
            description = description_node.children.to_s.strip.gsub(/\s{1,}/, ' ')
        end

        sql_query = <<SQL
    INSERT INTO categories
    (category_name, description)
    VALUES ('#{category}', "#{description || ''}");
SQL
        queries_array << sql_query
    end

    # TODO try/catch
    database.execute_batch(queries_array.join("\n"))
end

def is_package_invalid(item_path, package)
    # skip system dirs
    return true if ['.', '..'].index(package) != nil
    # skip if it is a file
    return true if  File.file?(item_path)
    # valid one! :)
    return false
end

def fill_packages_table(database, portage_home)
    queries_array = nil
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # get id of the current category from our db
        sql_query = "SELECT id FROM categories WHERE category_name='#{category}';"
        category_id = database.execute(sql_query)[0]
        queries_array = []

        # lets walk through all items in category dir
        Dir.new(File.join(portage_home, category)).sort.each do |package|
            # lets get full path for this item
            item_path = File.join(portage_home, category, package)
            # skip if it is a ..
            next if is_package_invalid(item_path, package)

            # get content of the last ebuild for this package
            ebuild_data = IO.read(Dir.glob(item_path + '/*.ebuild').sort.last).to_a
            description = get_ebuild_description(ebuild_data)
            homepage = get_ebuild_homepage(ebuild_data)

            sql_query = <<SQL
    INSERT INTO packages
    (category_id, package_name, description, homepage)
    VALUES (#{category_id}, '#{package}', \"#{description}\", '#{homepage}');
SQL
            queries_array << sql_query
        end
        # TODO try/catch
        database.execute_batch(queries_array.join("\n"))
    end
end

def store_package_maintainers(database, item_path)
    metadata_path = File.join(item_path, "metadata.xml")
    return unless File.exists?(metadata_path) && File.readable?(metadata_path)

    xml_doc = Nokogiri::XML(IO.read(metadata_path))
    maintainer_ids = []

    ['/maintainer', '/upstream/maintainer'].each do |xpath_item|
        xml_doc.xpath("/pkgmetadata" + xpath_item).each do |maintainer_node|
            email_node = maintainer_node.xpath('email')
            name_node = maintainer_node.xpath('name')
            email = email_node != nil ? email_node.children.to_s : ''
            name = name_node != nil ? name_node.children.to_s : ''
            #todo <description>Proxying maintainer.</description>
            next nil if email.empty?
            sql_query = "INSERT OR IGNORE INTO maintainers (email, name) VALUES (?, ?);"
            statement = database.prepare(sql_query)
            statement.execute(email, name)
            id_obj = {"id" => get_last_inserted_id(database)}
            id_obj["upstream"] = 1 if xpath_item.index('upstream') != nil
            maintainer_ids << id_obj
        end
    end

    return maintainer_ids
end

def fill_maintainers_table(database, portage_home)
    queries_array = []
    Dir.new(portage_home).sort.each do |category|
        # check if current item is valid for us
        next if is_category_invalid(portage_home, category)

        # lets walk through all items in category dir
        Dir.new(File.join(portage_home, category)).sort.each do |package|
            # lets get full path for this item
            item_path = File.join(portage_home, category, package)
            # skip if it is a ..
            next if is_package_invalid(item_path, package)

            maintainer_ids = store_package_maintainers(database, item_path)

            p maintainer_ids.size
            p maintainer_ids
            p item_path
            next if maintainer_ids.empty?
            maintainer_ids.each do |maintainer_obj|
                sql_query = <<SQL
INSERT INTO maintainers2packages
(maintainer_id, package_id)
VALUES (#{maintainer_obj['id']}, '(
    SELECT packages.id
    FROM packages, categories
    WHERE packages.package_name="#{package}" and categories.category_name="#{category}"
)');
SQL
                if (maintainer_obj.has_key?("upstream"))
                    sql_query.gsub!(/, package_id\)/, ", package_id, upstream_maintainer)")
                    sql_query.gsub!(/\)'\);/, ")', 1);")
                end
                #queries_array << sql_query
                p sql_query
                puts '='*9
                database.execute(sql_query)
            end
                puts '='*5
        end
    end
    # TODO try/catch
    #puts queries_array
    #database.execute_batch(queries_array.join("\n"))
end

def get_ebuild_description(ebuild_data)
    ebuild_data.each { |line|
        return get_clean_value(line) if line.index('DESCRIPTION=') != nil
    }

    return ''
end

def get_ebuild_homepage(ebuild_data)
    ebuild_data.each { |line|
        return get_clean_value(line) if line.index('HOMEPAGE=') != nil
    }

    return ''
end

def get_ebuild_mtime(line, structured_ebuild_data)
    if structured_ebuild_data.has_key?('mtime') == false
        if line.index('# $Header:') == 0
            date_str = line.match(/\d{4}\/\d\d\/\d\d \d\d:\d\d:\d\d/)
            structured_ebuild_data["mtime"] = date_str.to_s
        end
    end

    return structured_ebuild_data
end

def get_ebuild_author(line, structured_ebuild_data)
    if structured_ebuild_data.has_key?('author') == false
        if line.index('# $Header:') == 0
            author = line.match(/:\d\d (\w+) Exp \$$/)[1]
            structured_ebuild_data["author"] = author.to_s
        end
    end

    return structured_ebuild_data
end

def get_eapi(line, structured_ebuild_data)
    if structured_ebuild_data.has_key?('eapi') == false
        if line.index('EAPI') != nil
            structured_ebuild_data["eapi"] = get_clean_value(line)
        end
    end

    return structured_ebuild_data
end

def get_slot(line, structured_ebuild_data)
    if structured_ebuild_data.has_key?('slot') == false
        if line.index('SLOT') != nil
            structured_ebuild_data["slot"] = get_clean_value(line)
        end
    end

    return structured_ebuild_data
end

def get_license(line, structured_ebuild_data)
    if structured_ebuild_data.has_key?('licence') == false
        if line.index('LICENSE') != nil
            structured_ebuild_data["licence"] = get_clean_value(line)
        end
    end

    return structured_ebuild_data
end

def get_ebuild_version(ebuild_filename, structured_ebuild_data)
    match = ebuild_filename,match('-\d')
    if match == nil
        puts 'Failed to get version for ' + ebuild_filename
    else
        position = ebuild_filename,index(match)
        structured_ebuild_data["version"] = line[-(position + 1)..-1]
    end

    return structured_ebuild_data
end

def parse_ebuild(package_path, database)
    Dir.glob(package_path + '/*.ebuild').sort.each do |ebuild|
        ebuild_data = {}
        ebuild_data = get_ebuild_version(ebuild, ebuild_data)
        begin
            file = File.new(ebuild, "r")
            while (line = file.gets)
                ebuild_data = get_ebuild_mtime(line, ebuild_data)
                ebuild_data = get_ebuild_author(line, ebuild_data)
                ebuild_data = get_eapi(line, ebuild_data)
                ebuild_data = get_license(line, ebuild_data)
                ebuild_data = get_slot(line, ebuild_data)
                #ebuild_state INTEGER NOT NULL,
                #architecture INTEGER NOT NULL,
            end
            file.close
        rescue => err
            puts "Exception: #{err}"
            err
        end
    end
end

# hash with options
options = {
    :db_filename => nil,
    :storage => {},
    :quiet => true
}

# lets merge stuff from tools lib
options[:storage].merge!(STORAGE)
# get last created database
options[:db_filename] = get_last_created_database(
    options[:storage][:root],
    options[:storage][:home_folder]
)

OptionParser.new do |opts|
    # help header
    opts.banner = " Usage: purge_s3_data [options]\n"
    opts.separator " A script that purges outdated data from s3 bucket\n"

    opts.on("-f", "--database-file STRING", "Path where new database file will be created") do |value|
        # TODO check if path id valid
        options[:db_filename] = value
    end

    # parsing 'quite' option if present
    opts.on("-q", "--quiet", "Quiet mode") do |value|
        options[:quiet] = true
    end

    # parsing 'help' option if present
    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end
end.parse!

portage_home = File.join(
    options[:storage][:root],
    options[:storage][:home_folder],
    options[:storage][:portage_home]
)

#begin
    db = SQLite3::Database.new(options[:db_filename])

    start = Time.now

    # fill static/predefined data
    fill_architecture_table(db, portage_home)
    fill_keywords_table(db)

    # fill ebuilds data
    fill_categories_table(db, portage_home)
    fill_packages_table(db, portage_home)
    fill_maintainers_table(db, portage_home)
    #fill_ebuilds_table(db, portage_home)

    finish = Time.now

    puts 'Everything is OK!'
    puts start
    puts finish
#rescue Exception => msg
    #File.delete(options[:db_filename])
    #puts msg
#ensure
    db.close() if db.closed? == false
#end
