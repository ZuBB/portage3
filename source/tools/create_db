#!/usr/bin/env ruby
#
# Here should go some comment
#
# Initial Author: Vasyl Zuzyak, 01/04/12
# Latest Modification: Vasyl Zuzyak, 01/06/12
#
$:.push File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'optparse'
require 'rubygems'
require 'sqlite3'
require 'tools'

# hash with sql code of all tables
databases = {}
# hash with default options
options = {
    :db_filename => File.join(
        STORAGE[:root],
        STORAGE[:home_folder],
        "test-#{get_timestamp()}.sqlite"
    ),
    :verbose => false
}

databases["categories"] = <<SQL_TABLE_CATEGORIES
create table categories (
    id INTEGER PRIMARY KEY,
    category_name text UNIQUE NOT NULL,
    description text NOT NULL
);
SQL_TABLE_CATEGORIES

databases["packages"] = <<SQL_TABLE_PACKAGES
create table packages (
    id INTEGER PRIMARY KEY,
    -- combination of next two fields should be unique
    category_id INTEGER NOT NULL,
    package_name text NOT NULL,
    description text NOT NULL,
    homepage text NOT NULL,
    maintainer_id INTEGER,
    CONSTRAINT unq UNIQUE (category_id, package_name)
);
SQL_TABLE_PACKAGES

databases["maintainers"] = <<SQL_TABLE_MAINTAINERS
create table maintainers (
    id INTEGER PRIMARY KEY,
    name text,
    email text,
    CONSTRAINT unq UNIQUE (name, email)
);
SQL_TABLE_MAINTAINERS

databases["ebuilds"] = <<SQL_TABLE_EBUILDS
create table ebuilds (
    id INTEGER PRIMARY KEY,
    package_id INTEGER NOT NULL,
    version text NOT NULL,
    --licence_id INTEGER NOT NULL,
    licence text NOT NULL,
    data blob /*NOT NULL*/,
    keyword_id INTEGER NOT NULL,
    architecture INTEGER NOT NULL,
    mtime INTEGER NOT NULL,
    mauthor text NOT NULL,
    eapi INTEGER /*NOT NULL*/,
    slot INTEGER NOT NULL
    -- depend TODO
    -- rdepend TODO
    -- sha1/md5 INTEGER NOT NULL
    -- overlay?
    -- size of dwonloads?
    -- compile_flags?
);
SQL_TABLE_EBUILDS

databases["use_flags"] = <<SQL_TABLE_USE_FLAGS
Create table use_flags (
    id INTEGER PRIMARY KEY,
    flag_name text NOT NULL,
    flag_description text NOT NULL
);
SQL_TABLE_USE_FLAGS

databases["use_flags2ebuilds"] = <<SQL_TABLE_USE_FLAGS2EBUILDS
Create table use_flags2ebuilds (
    id INTEGER PRIMARY KEY,
    flag_id INTEGER NOT NULL,
    ebuild_id INTEGER NOT NULL
);
SQL_TABLE_USE_FLAGS2EBUILDS

databases["architectures"] = <<SQL_TABLE_ARCHITECTURES
Create table architectures (
    id INTEGER PRIMARY KEY,
    architecture text UNIQUE NOT NULL
    -- smth else?
);
SQL_TABLE_ARCHITECTURES

databases["ebuilds2architectures"] = <<SQL_TABLE_EBUILDS2ARCHITECTURES
Create table ebuilds2architectures (
    id INTEGER PRIMARY KEY,
    ebuild_id INTEGER NOT NULL,
    architecture_id INTEGER NOT NULL
);
SQL_TABLE_EBUILDS2ARCHITECTURES

databases["keywords"] = <<SQL_TABLE_KEYWORDS
Create table keywords (
    id INTEGER PRIMARY KEY,
    keyword text UNIQUE NOT NULL/*,
    keyword_description text NOT NULL*/
);
SQL_TABLE_KEYWORDS

databases["keywords2architectures"] = <<SQL_TABLE_KEYWORDS2ARCH
Create table keywords2architectures (
    id INTEGER PRIMARY KEY,
    ebuild_architecture_id INTEGER NOT NULL,
    keyword_id INTEGER NOT NULL
);
SQL_TABLE_KEYWORDS2ARCH

databases["licences"] = <<SQL_TABLE_LICENCES
create table licences (
    id INTEGER PRIMARY KEY,
    license_name text NOT NULL
    -- url text ?,
    -- content blob /*zipped data*/ ?
);
SQL_TABLE_LICENCES

databases["licences2ebuilds"] = <<SQL_TABLE_LICENCES2EBUILDS
create table licences2ebuilds (
    id INTEGER PRIMARY KEY,
    license_id INTEGER NOT NULL,
    ebuild_id INTEGER NOT NULL
);
SQL_TABLE_LICENCES2EBUILDS

databases["sets"] = <<SQL_TABLE_SETS
create table sets (
    id INTEGER PRIMARY KEY,
    set_name text NOT NULL
);
SQL_TABLE_SETS

databases["sets_content"] = <<SQL_TABLE_SETS_CONTENT
create table sets_content (
    id INTEGER PRIMARY KEY,
    set_id text INTEGER NOT NULL,
    package_id text INTEGER NOT NULL
);
SQL_TABLE_SETS_CONTENT

OptionParser.new do |opts|
    # help header
    opts.banner = " Usage: purge_s3_data [options]\n"
    opts.separator " A script that purges outdated data from s3 bucket\n"

    # parsing 'db_filename' option if present
    opts.on("-f", "--database-file STRING",
            "Path where new database file will be created") do |value|
        if File.exists?(value)
            puts "ERROR: file '#{value}' already exists!"
            exit(1)
        end

        base_dir = File.dirname(value)

        if !File.exists?(base_dir)
            puts "ERROR: directory '#{base_dir}' does not exist!"
            exit(1)
        end

        if !File.writable?(base_dir)
            puts "ERROR: directory '#{base_dir}' is not writable!"
            exit(1)
        end

        options[:db_filename] = value
    end

    # parsing 'verbose' option if present
    opts.on("-v", "--[no]-verbose", "Versbose mode") do |value|
        options[:verbose] = value
    end

    # parsing 'help' option if present
    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end
end.parse!

sql = <<SQL_ALL_TABLES
#{databases["categories"]}
#{databases["packages"]}
#{databases["maintainers"]}
#{databases["ebuilds"]}
#{databases["use_flags"]}
#{databases["use_flags2ebuilds"]}
#{databases["architectures"]}
#{databases["ebuilds2architectures"]}
#{databases["keywords"]}
#{databases["keywords2architectures"]}
#{databases["licences"]}
#{databases["licences2ebuilds"]}
SQL_ALL_TABLES

# print sql if verbose is set
puts sql if options[:verbose]

begin
    db = SQLite3::Database.new(options[:db_filename])
    db.execute_batch(sql)
    puts 'Everything is OK. Database was created at:'
    puts options[:db_filename]
rescue Exception => msg
    File.delete(options[:db_filename])
    puts msg
ensure
    db.close() if db.closed? == false
end

